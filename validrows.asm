# MIPS asm generated on: 2016-04-18 19:39:39.795000
# By: Matthew Dennis (msd7734)

	.align 2
	.data

 	.globl	valid_rows

size_err:
	.word	0
	
# data pointer table
rows_tbl:
	.word	row_bsize2
	.word	row_bsize3
	.word	row_bsize4
	.word	row_bsize5
	.word	row_bsize6
	.word	row_bsize7
	.word	row_bsize8
	.word	row_bsize9
	.word	row_bsize10
	
# Valid rows for board size 2
row_bsize2:
	.half	2
	.half	0x001, 0x002

# Valid rows for board size 3
row_bsize3:
	.half	3
	.half	0x003, 0x005, 0x006

# Valid rows for board size 4
row_bsize4:
	.half	6
	.half	0x003, 0x005, 0x006, 0x009, 0x00a, 0x00c

# Valid rows for board size 5
row_bsize5:
	.half	7
	.half	0x00b, 0x00d, 0x013, 0x015, 0x016, 0x019
	.half	0x01a

# Valid rows for board size 6
row_bsize6:
	.half	14
	.half	0x00b, 0x00d, 0x013, 0x015, 0x016, 0x019
	.half	0x01a, 0x025, 0x026, 0x029, 0x02a, 0x02c
	.half	0x032, 0x034

# Valid rows for board size 7
row_bsize7:
	.half	18
	.half	0x01b, 0x02b, 0x02d, 0x033, 0x035, 0x036
	.half	0x04b, 0x04d, 0x053, 0x055, 0x056, 0x059
	.half	0x05a, 0x065, 0x066, 0x069, 0x06a, 0x06c

# Valid rows for board size 8
row_bsize8:
	.half	34
	.half	0x02b, 0x02d, 0x033, 0x035, 0x036, 0x04b
	.half	0x04d, 0x053, 0x055, 0x056, 0x059, 0x05a
	.half	0x065, 0x066, 0x069, 0x06a, 0x06c, 0x093
	.half	0x095, 0x096, 0x099, 0x09a, 0x0a5, 0x0a6
	.half	0x0a9, 0x0aa, 0x0ac, 0x0b2, 0x0b4, 0x0c9
	.half	0x0ca, 0x0cc, 0x0d2, 0x0d4

# Valid rows for board size 9
row_bsize9:
	.half	45
	.half	0x05b, 0x06b, 0x06d, 0x09b, 0x0ab, 0x0ad
	.half	0x0b3, 0x0b5, 0x0b6, 0x0cb, 0x0cd, 0x0d3
	.half	0x0d5, 0x0d6, 0x0d9, 0x0da, 0x12b, 0x12d
	.half	0x133, 0x135, 0x136, 0x14b, 0x14d, 0x153
	.half	0x155, 0x156, 0x159, 0x15a, 0x165, 0x166
	.half	0x169, 0x16a, 0x16c, 0x193, 0x195, 0x196
	.half	0x199, 0x19a, 0x1a5, 0x1a6, 0x1a9, 0x1aa
	.half	0x1ac, 0x1b2, 0x1b4

# Valid rows for board size 10
row_bsize10:
	.half	84
	.half	0x09b, 0x0ab, 0x0ad, 0x0b3, 0x0b5, 0x0b6
	.half	0x0cb, 0x0cd, 0x0d3, 0x0d5, 0x0d6, 0x0d9
	.half	0x0da, 0x12b, 0x12d, 0x133, 0x135, 0x136
	.half	0x14b, 0x14d, 0x153, 0x155, 0x156, 0x159
	.half	0x15a, 0x165, 0x166, 0x169, 0x16a, 0x16c
	.half	0x193, 0x195, 0x196, 0x199, 0x19a, 0x1a5
	.half	0x1a6, 0x1a9, 0x1aa, 0x1ac, 0x1b2, 0x1b4
	.half	0x24b, 0x24d, 0x253, 0x255, 0x256, 0x259
	.half	0x25a, 0x265, 0x266, 0x269, 0x26a, 0x26c
	.half	0x293, 0x295, 0x296, 0x299, 0x29a, 0x2a5
	.half	0x2a6, 0x2a9, 0x2aa, 0x2ac, 0x2b2, 0x2b4
	.half	0x2c9, 0x2ca, 0x2cc, 0x2d2, 0x2d4, 0x325
	.half	0x326, 0x329, 0x32a, 0x32c, 0x332, 0x334
	.half	0x349, 0x34a, 0x34c, 0x352, 0x354, 0x364

	.text

#############################
# valid_rows
# Access all possible valid row data for a given board size.
# Args:
#  a0 - Length of the side of a (square) board.
# Returns:
#  v0 - ptr to 0 if the length is unsupported, or ptr to a row_listing
#       in the following format:
#		struct row_listing {
# 			int16 count;
# 			int16 row_data[count];
# 		}
#############################
valid_rows:
	slti	$t0, $a0, 11		# check valid size: 2 <= x <= 10
	slti	$t1, $a0, 2
	nor	$t1, $t1, $zero
	and	$t2, $t0, $t1
	li	$t3, 1			# ensure size is even too
	and	$t4, $a0, $t3		# size & 1 = 1 if size is odd
	xor	$t4, $t4, $t3
	and	$t2, $t2, $t4
	beq	$t2, $zero, bad_length
	
	la	$t0, rows_tbl		# t0 = rows_tbl&
	addi	$t1, $a0, -2		# offset = (length-2)*4
	mul	$t1, $t1, 4
	add	$t2, $t0, $t1		# return (rows_tbl& + offset)
	lw	$v0, 0($t2)
	j	done
bad_length:
	la	$v0, size_err
done:
	jr	$ra
